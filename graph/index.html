<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
      /* Variables CSS pour les th√®mes */
      :root {
        --bg-color: #ffffff;
        --text-color: #000000;
        --sidebar-bg: #ffffff;
        --sidebar-border: #cccccc;
        --sidebar-shadow: rgba(0, 0, 0, 0.1);
        --search-bg: #ffffff;
        --search-border: #dddddd;
        --search-shadow: rgba(0, 0, 0, 0.1);
        --input-border: #cccccc;
        --input-bg: #ffffff;
        --result-hover: #f0f0f0;
        --result-border: #eeeeee;
        --connection-bg: #f5f5f5;
        --section-border: #eeeeee;
        --text-secondary: #666666;
        --text-tertiary: #333333;
        --link-stroke: #000000;
        --text-stroke: rgba(0, 0, 0, 0.5);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg-color: #1a1a1a;
          --text-color: #ffffff;
          --sidebar-bg: #2d2d2d;
          --sidebar-border: #444444;
          --sidebar-shadow: rgba(0, 0, 0, 0.3);
          --search-bg: #2d2d2d;
          --search-border: #444444;
          --search-shadow: rgba(0, 0, 0, 0.3);
          --input-border: #555555;
          --input-bg: #3a3a3a;
          --result-hover: #3a3a3a;
          --result-border: #444444;
          --connection-bg: #3a3a3a;
          --section-border: #444444;
          --text-secondary: #aaaaaa;
          --text-tertiary: #cccccc;
          --link-stroke: #ffffff;
          --text-stroke: rgba(255, 255, 255, 0.5);
        }
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-color);
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .link {
        stroke: var(--link-stroke);
        stroke-width: 1px;
      }
      circle {
        opacity: 0.5;
      }
      text {
        paint-order: stroke;
        stroke-opacity: 0.5;
        fill: var(--text-color);
        stroke: var(--text-stroke);
      }
      .node,
      .labels:hover {
        cursor: pointer;
      }
      svg:active {
        cursor: move;
      }
      #sidebar {
        position: fixed;
        top: 20px;
        left: 20px;
        width: 360px;
        max-height: calc(100vh - 40px);
        background: var(--sidebar-bg);
        border: 1px solid var(--sidebar-border);
        border-radius: 8px;
        box-shadow: 0 2px 10px var(--sidebar-shadow);
        transition: all 0.3s ease;
        padding: 0;
        overflow: hidden;
        z-index: 1001;
        display: none;
        flex-direction: column;
        color: var(--text-color);
      }
      #sidebar.open {
        display: flex;
      }
      
      /* Cacher la recherche quand la sidebar est ouverte */
      #search-container.hidden-by-sidebar {
        display: none;
      }
      #sidebar-header {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 0;
        border-bottom: 1px solid var(--section-border);
        padding: 20px;
        color: var(--text-color);
        background: var(--connection-bg);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      #sidebar-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 20px;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.3s ease;
      }
      #sidebar-close:hover {
        background: var(--result-hover);
        color: var(--text-color);
      }
      #sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
      }
      .connection-section {
        margin-bottom: 20px;
      }
      .connection-section h3 {
        margin: 0 0 10px 0;
        color: var(--text-tertiary);
      }
      .connection-item {
        margin-bottom: 8px;
        padding: 8px;
        background: var(--connection-bg);
        border-radius: 4px;
        color: var(--text-color);
      }
      .connection-type {
        font-weight: bold;
        color: var(--text-secondary);
      }
      #search-container {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1001;
        background: var(--search-bg);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px var(--search-shadow);
        border: 1px solid var(--search-border);
        min-width: 300px;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      #search-input {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--input-border);
        border-radius: 4px;
        font-size: 14px;
        margin-bottom: 10px;
        background: var(--input-bg);
        color: var(--text-color);
        transition: background-color 0.3s ease, border-color 0.3s ease,
          color 0.3s ease;
      }
      #search-input::placeholder {
        color: var(--text-secondary);
      }
      #search-results {
        max-height: 200px;
        overflow-y: auto;
      }
      .search-result {
        padding: 8px;
        cursor: pointer;
        border-bottom: 1px solid var(--result-border);
        display: flex;
        justify-content: space-between;
        color: var(--text-color);
        transition: background-color 0.3s ease;
      }
      .search-result:hover {
        background: var(--result-hover);
      }
      .search-result:last-child {
        border-bottom: none;
      }
      .search-node-label {
        font-size: 12px;
        color: var(--text-secondary);
      }
      .highlighted {
        stroke: red !important;
        stroke-width: 3px !important;
        opacity: 1 !important;
      }
      .highlighted-text {
        fill: red !important;
        font-weight: bold !important;
        opacity: 1 !important;
      }
      #depth-selector {
        margin-top: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--text-color);
      }
      #depth-select {
        padding: 4px;
        border: 1px solid var(--input-border);
        border-radius: 4px;
        font-size: 12px;
        background: var(--input-bg);
        color: var(--text-color);
        transition: background-color 0.3s ease, border-color 0.3s ease,
          color 0.3s ease;
      }
      .depth-highlighted {
        opacity: 0.8 !important;
      }
      .depth-faded {
        opacity: 0.1 !important;
      }

      /* Style pour les liens et textes dans le footer */
      a {
        color: var(--text-color);
        transition: color 0.3s ease;
      }
      a:hover {
        opacity: 0.8;
      }

      /* Styles pour l'itin√©raire */
      .path-link {
        stroke: #ff6b00 !important;
        stroke-width: 4px !important;
        opacity: 1 !important;
        animation: pathPulse 2s infinite;
      }
      
      @keyframes pathPulse {
        0%, 100% { stroke-width: 4px; }
        50% { stroke-width: 6px; }
      }
      
      .path-node {
        stroke: #ff6b00 !important;
        stroke-width: 4px !important;
        opacity: 1 !important;
      }

      #route-panel {
        position: fixed;
        top: 20px;
        left: 20px;
        width: 360px;
        max-height: calc(100vh - 40px);
        background: var(--sidebar-bg);
        border: 1px solid var(--sidebar-border);
        border-radius: 8px;
        box-shadow: 0 2px 10px var(--sidebar-shadow);
        transition: all 0.3s ease;
        z-index: 1002;
        display: none;
        flex-direction: column;
      }

      #route-panel.visible {
        display: flex;
      }

      /* Cacher la zone de recherche quand l'itin√©raire est ouvert */
      #search-container.hidden {
        display: none;
      }

      .route-header {
        background: var(--connection-bg);
        padding: 20px;
        border-bottom: 1px solid var(--section-border);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .route-title {
        font-size: 18px;
        font-weight: bold;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .route-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 20px;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.3s ease;
      }

      .route-close:hover {
        background: var(--result-hover);
        color: var(--text-color);
      }

      .route-inputs {
        padding: 20px;
        border-bottom: 1px solid var(--section-border);
      }

      .input-group {
        position: relative;
        margin-bottom: 12px;
      }

      .input-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 16px;
        color: var(--text-secondary);
        z-index: 1;
      }

      .route-input {
        width: 100%;
        padding: 12px 12px 12px 40px;
        border: 2px solid var(--input-border);
        border-radius: 8px;
        font-size: 14px;
        background: var(--input-bg);
        color: var(--text-color);
        transition: all 0.3s ease;
        box-sizing: border-box;
      }

      .route-input:focus {
        outline: none;
        border-color: #4285f4;
        box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
      }

      .route-input::placeholder {
        color: var(--text-secondary);
      }

      .swap-button {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: var(--input-bg);
        border: 1px solid var(--input-border);
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 2;
      }

      .swap-button:hover {
        background: var(--result-hover);
        transform: translateY(-50%) scale(1.1);
      }

      .autocomplete-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--input-bg);
        border: 1px solid var(--input-border);
        border-top: none;
        border-radius: 0 0 8px 8px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 10;
        box-shadow: 0 4px 6px var(--search-shadow);
      }

      .autocomplete-item {
        padding: 12px 16px;
        cursor: pointer;
        border-bottom: 1px solid var(--section-border);
        display: flex;
        align-items: center;
        gap: 8px;
        transition: background-color 0.3s ease;
      }

      .autocomplete-item:hover {
        background: var(--result-hover);
      }

      .autocomplete-item:last-child {
        border-bottom: none;
      }

      .route-button {
        background: #4285f4;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 0 20px 20px;
      }

      .route-button:hover {
        background: #3367d6;
        transform: translateY(-1px);
      }

      .route-button:disabled {
        background: var(--text-secondary);
        cursor: not-allowed;
        transform: none;
      }

      .route-results {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        max-height: 400px;
      }

      .route-summary {
        background: var(--connection-bg);
        padding: 16px;
        border-radius: 8px;
        margin-bottom: 16px;
        border-left: 4px solid #4285f4;
      }

      .route-time {
        font-size: 18px;
        font-weight: bold;
        color: var(--text-color);
        margin-bottom: 4px;
      }

      .route-distance {
        font-size: 14px;
        color: var(--text-secondary);
      }

      .route-steps {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .route-step {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 8px 0;
        border-bottom: 1px solid var(--section-border);
      }

      .route-step:last-child {
        border-bottom: none;
      }

      .step-number {
        background: #4285f4;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        flex-shrink: 0;
      }

      .step-content {
        flex: 1;
      }

      .step-title {
        font-weight: 500;
        color: var(--text-color);
        margin-bottom: 2px;
      }

      .step-relation {
        font-size: 12px;
        color: var(--text-secondary);
      }

      .clear-route {
        background: none;
        border: 1px solid var(--input-border);
        color: var(--text-color);
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        margin: 0 20px;
        transition: all 0.3s ease;
      }

      .clear-route:hover {
        background: var(--result-hover);
      }
    </style>
  </head>
  <body>
    <div id="search-container">
      <input type="text" id="search-input" placeholder="Search for nodes..." />
      <div id="search-results"></div>
      <div id="depth-selector">
        <label for="depth-select">Connection depth:</label>
        <select id="depth-select">
          <option value="0">Show all</option>
          <option value="1">1 level</option>
          <option value="2">2 levels</option>
          <option value="3">3 levels</option>
          <option value="4">4 levels</option>
          <option value="5">5 levels</option>
        </select>
      </div>
    </div>
    <div id="sidebar">
      <div id="sidebar-header">
        <span id="sidebar-close">&times;</span>
        <span id="node-title">Node Details</span>
      </div>
      <div id="sidebar-content"></div>
    </div>
    
    <div id="route-panel">
      <div class="route-header">
        <div class="route-title">
          üó∫Ô∏è Itin√©raires
        </div>
        <button class="route-close" id="close-route">&times;</button>
      </div>
      
      <div class="route-inputs">
        <div class="input-group">
          <div class="input-icon">üìç</div>
          <input type="text" class="route-input" id="from-input" placeholder="Point de d√©part" />
          <div class="autocomplete-results" id="from-results"></div>
        </div>
        
        <div class="input-group">
          <div class="input-icon">üéØ</div>
          <input type="text" class="route-input" id="to-input" placeholder="Destination" />
          <button class="swap-button" id="swap-route" title="√âchanger les points">‚ÜïÔ∏è</button>
          <div class="autocomplete-results" id="to-results"></div>
        </div>
      </div>
      
      <button class="route-button" id="find-route" style="display: none;">Calculer l'itin√©raire</button>
      
      <div class="route-results" id="route-results">
        <!-- Les r√©sultats d'itin√©raire appara√Ætront ici -->
      </div>
      
      <button class="clear-route" id="clear-route" style="display: none;">Effacer l'itin√©raire</button>
    </div>
    
    <div>
      Fonctionnement de l'Union Europ√©enne
      <a
        href="https://europa.eu/european-union/about-eu/institutions-bodies_fr"
      >
        Sources
      </a>
      <a href="/graph/3d/">En 3D</a>
    </div>
  </body>
  <script src="https://d3js.org/d3.v4.min.js" type="text/javascript"></script>
  <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
  <script type="text/javascript">
    var color = d3.scaleOrdinal(d3.schemeCategory20);
    var labelColors = d3.scaleOrdinal([
      "#404040",
      "white",
      "#ffd617",
      "#004494",
    ]);
    var idColors = d3.scaleOrdinal([
      "DarkOrange ",
      "DarkRed",
      "DarkGreen",
      "DarkMagenta",
      "DarkCyan",
      "DarkBlue",
      "DarkSalmon",
    ]);
    var width = window.innerWidth - 40,
      height = window.innerHeight - 40,
      radius = 0;
    var zoom = d3.zoom().on("zoom", function () {
      svg.attr("transform", d3.event.transform);
    });
    var svg = d3
      .select("body")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .call(zoom)
      .append("g");
    var node;
    var link;
    var label;

    svg
      .append("defs")
      .append("marker")
      .attrs({
        id: "arrowhead",
        viewBox: "-0 -5 10 10",
        refX: 13,
        refY: 0,
        orient: "auto",
        markerWidth: 13,
        markerHeight: 13,
        xoverflow: "visible",
      })
      .append("svg:path")
      .attr("d", "M 0,-5 L 10 ,0 L 0,5")
      .attr("fill", "var(--text-secondary)")
      .style("stroke", "none");

    var simulation = d3
      .forceSimulation()
      .force(
        "link",
        d3.forceLink().id(function (d) {
          return d.id;
        })
        // .distance(function(d){
        // 	return (d.type.length * 2 + 100)
        // })
      )
      .force(
        "collide",
        d3
          .forceCollide(function (d) {
            return d.id;
          })
          .strength(1)
          .radius(5)
          .iterations(1)
      )
      .force("charge", d3.forceManyBody().strength(-1500))
      .force("center", d3.forceCenter(width / 2, height / 2));

    var allLinks = []; // Store all links for sidebar functionality
    var allNodes = []; // Store all nodes for search functionality
    var highlightedNode = null; // Track currently highlighted node
    var currentDepth = 0; // Current depth setting
    
    // Variables pour l'itin√©raire
    var routeMode = false; // Mode itin√©raire activ√©
    var routeStartNode = null; // N≈ìud de d√©part
    var routeEndNode = null; // N≈ìud de destination
    var currentPath = []; // Chemin actuel
    var pathLinks = []; // Liens du chemin

    function getConnectedNodes(startNodeId, depth) {
      if (depth === 0) {
        return new Set(allNodes.map((n) => n.id));
      }

      const visited = new Set();
      const queue = [{ id: startNodeId, level: 0 }];

      while (queue.length > 0) {
        const { id, level } = queue.shift();

        if (visited.has(id) || level > depth) continue;
        visited.add(id);

        if (level < depth) {
          // Add connected nodes to queue
          allLinks.forEach((link) => {
            if (link.source.id === id && !visited.has(link.target.id)) {
              queue.push({ id: link.target.id, level: level + 1 });
            }
            if (link.target.id === id && !visited.has(link.source.id)) {
              queue.push({ id: link.source.id, level: level + 1 });
            }
          });
        }
      }

      return visited;
    }

    function applyDepthFilter() {
      if (!highlightedNode || currentDepth === 0) {
        // Show all nodes and links
        node.classed("depth-faded", false).classed("depth-highlighted", false);
        label.classed("depth-faded", false).classed("depth-highlighted", false);
        link.classed("depth-faded", false).classed("depth-highlighted", false);
        return;
      }

      const connectedNodeIds = getConnectedNodes(
        highlightedNode.id,
        currentDepth
      );

      // Fade nodes not in the connected set
      node
        .classed("depth-faded", (d) => !connectedNodeIds.has(d.id))
        .classed(
          "depth-highlighted",
          (d) => connectedNodeIds.has(d.id) && d.id !== highlightedNode.id
        );

      label
        .classed("depth-faded", (d) => !connectedNodeIds.has(d.id))
        .classed(
          "depth-highlighted",
          (d) => connectedNodeIds.has(d.id) && d.id !== highlightedNode.id
        );

      // Fade links not connecting nodes in the set
      link
        .classed(
          "depth-faded",
          (d) =>
            !connectedNodeIds.has(d.source.id) ||
            !connectedNodeIds.has(d.target.id)
        )
        .classed(
          "depth-highlighted",
          (d) =>
            connectedNodeIds.has(d.source.id) &&
            connectedNodeIds.has(d.target.id)
        );
    }

    function searchNodes(query) {
      if (!query.trim()) {
        document.getElementById("search-results").innerHTML = "";
        return;
      }

      const results = allNodes.filter((node) =>
        node.id.toLowerCase().includes(query.toLowerCase())
      );

      let resultsHTML = "";
      results.slice(0, 10).forEach((node) => {
        // Limit to 10 results
        const label = node.label ? ` (${node.label})` : "";
        resultsHTML += `
          <div class="search-result" onclick="focusNode('${node.id.replace(
            /'/g,
            "\\'"
          )}')"> 
            <span>${node.id}</span>
            <span class="search-node-label">${label}</span>
          </div>`;
      });

      if (results.length === 0) {
        resultsHTML = '<div class="search-result">No nodes found</div>';
      }

      document.getElementById("search-results").innerHTML = resultsHTML;
    }

    function focusNode(nodeId) {
      // Clear previous highlighting
      if (highlightedNode) {
        node.classed("highlighted", false);
        label.classed("highlighted-text", false);
      }

      // Find the node
      const targetNode = allNodes.find((n) => n.id === nodeId);
      if (!targetNode) return;

      // Highlight the node
      node.classed("highlighted", (d) => d.id === nodeId);
      label.classed("highlighted-text", (d) => d.id === nodeId);

      // Pan and zoom to center the node
      const scale = 2; // Zoom level
      const translate = [
        width / 2 - targetNode.x * scale,
        height / 2 - targetNode.y * scale,
      ];

      // Apply the transform to the main SVG element
      d3.select("body")
        .select("svg")
        .transition()
        .duration(750)
        .call(
          zoom.transform,
          d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
        );

      highlightedNode = targetNode;

      // Apply depth filter
      applyDepthFilter();

      // Clear search results
      document.getElementById("search-results").innerHTML = "";
      document.getElementById("search-input").value = "";

      // Show sidebar for this node
      showSidebar(targetNode);
    }

    function showSidebar(nodeData) {
      const sidebar = document.getElementById("sidebar");
      const searchContainer = document.getElementById("search-container");
      const nodeTitle = document.getElementById("node-title");
      const sidebarContent = document.getElementById("sidebar-content");

      nodeTitle.textContent = nodeData.id;

      // Find connections where this node is source or target
      const outgoingLinks = allLinks.filter(
        (link) => link.source.id === nodeData.id
      );
      const incomingLinks = allLinks.filter(
        (link) => link.target.id === nodeData.id
      );

      let content = "";

      // Add node label information
      if (nodeData.label) {
        content += `<div class="connection-section">
          <h3>Node Information</h3>
          <div class="connection-item">
            <div class="connection-type">Type:</div>
            <div>${nodeData.label}</div>
          </div>
        </div>`;
      }

      // Ajouter le bouton d'itin√©raire
      content += `<div class="connection-section">
        <h3>Actions</h3>
        <div class="connection-item">
          <button class="route-btn" onclick="showRoute()" style="width: 100%; background: #4285f4; color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer;">
            üó∫Ô∏è Cr√©er un itin√©raire vers ce n≈ìud
          </button>
        </div>
      </div>`;

      if (outgoingLinks.length > 0) {
        content +=
          '<div class="connection-section"><h3>Outgoing Connections</h3>';
        outgoingLinks.forEach((link) => {
          const targetLabel = link.target.label
            ? ` (${link.target.label})`
            : "";
          content += `<div class="connection-item">
            <div class="connection-type">${link.type}</div>
            <div>‚Üí ${link.target.id}${targetLabel}</div>
          </div>`;
        });
        content += "</div>";
      }

      if (incomingLinks.length > 0) {
        content +=
          '<div class="connection-section"><h3>Incoming Connections</h3>';
        incomingLinks.forEach((link) => {
          const sourceLabel = link.source.label
            ? ` (${link.source.label})`
            : "";
          content += `<div class="connection-item">
            <div class="connection-type">${link.type}</div>
            <div>‚Üê ${link.source.id}${sourceLabel}</div>
          </div>`;
        });
        content += "</div>";
      }

      if (outgoingLinks.length === 0 && incomingLinks.length === 0) {
        content += "<div>No connections found for this node.</div>";
      }

      sidebarContent.innerHTML = content;
      
      // Cacher la recherche et l'itin√©raire, montrer la sidebar
      searchContainer.classList.add("hidden-by-sidebar");
      document.getElementById("route-panel").classList.remove("visible");
      sidebar.classList.add("open");
    }

    function closeSidebar() {
      const sidebar = document.getElementById("sidebar");
      const searchContainer = document.getElementById("search-container");
      
      sidebar.classList.remove("open");
      searchContainer.classList.remove("hidden-by-sidebar");
    }

    // Fonctions pour l'itin√©raire
    function findShortestPath(startId, endId) {
      if (startId === endId) return [startId];
      
      const visited = new Set();
      const queue = [{ node: startId, path: [startId] }];
      
      while (queue.length > 0) {
        const { node: currentNode, path } = queue.shift();
        
        if (visited.has(currentNode)) continue;
        visited.add(currentNode);
        
        // Trouver tous les n≈ìuds connect√©s
        const connectedNodes = [];
        allLinks.forEach(link => {
          if (link.source.id === currentNode && !visited.has(link.target.id)) {
            connectedNodes.push(link.target.id);
          }
          if (link.target.id === currentNode && !visited.has(link.source.id)) {
            connectedNodes.push(link.source.id);
          }
        });
        
        for (const nextNode of connectedNodes) {
          const newPath = [...path, nextNode];
          
          if (nextNode === endId) {
            return newPath;
          }
          
          if (!visited.has(nextNode)) {
            queue.push({ node: nextNode, path: newPath });
          }
        }
      }
      
      return []; // Aucun chemin trouv√©
    }

    function showRoute() {
      const routePanel = document.getElementById("route-panel");
      const searchContainer = document.getElementById("search-container");
      const sidebar = document.getElementById("sidebar");
      const toInput = document.getElementById("to-input");
      
      if (highlightedNode) {
        routeEndNode = highlightedNode;
        toInput.value = highlightedNode.id;
        
        // Cacher la recherche et la sidebar, montrer l'itin√©raire
        searchContainer.classList.add("hidden");
        sidebar.classList.remove("open");
        routePanel.classList.add("visible");
        routeMode = true;
        
        // Focus sur le champ origine
        setTimeout(() => {
          document.getElementById("from-input").focus();
        }, 100);
      }
    }

    function clearRoute() {
      // Supprimer la surbrillance du chemin
      if (link) link.classed("path-link", false);
      if (node) node.classed("path-node", false);
      
      // Reset des variables
      routeEndNode = null;
      currentPath = [];
      pathLinks = [];
      
      // Nettoyer l'interface
      document.getElementById("to-input").value = "";
      document.getElementById("to-results").innerHTML = "";
      document.getElementById("route-results").innerHTML = "";
      document.getElementById("find-route").disabled = true;
      document.getElementById("clear-route").style.display = "none";
      
      routeMode = false;
    }

    function closeRoute() {
      // Supprimer la surbrillance du chemin
      if (link) link.classed("path-link", false);
      if (node) node.classed("path-node", false);
      
      // Reset complet des variables
      routeStartNode = null;
      routeEndNode = null;
      currentPath = [];
      pathLinks = [];
      
      // Cacher l'interface d'itin√©raire et r√©afficher la recherche
      const routePanel = document.getElementById("route-panel");
      const searchContainer = document.getElementById("search-container");
      const sidebar = document.getElementById("sidebar");
      
      routePanel.classList.remove("visible");
      sidebar.classList.remove("open");
      searchContainer.classList.remove("hidden");
      searchContainer.classList.remove("hidden-by-sidebar");
      
      // Nettoyer les champs
      document.getElementById("from-input").value = "";
      document.getElementById("to-input").value = "";
      document.getElementById("to-results").innerHTML = "";
      document.getElementById("route-results").innerHTML = "";
      document.getElementById("find-route").disabled = true;
      document.getElementById("clear-route").style.display = "none";
      
      routeMode = false;
    }

    function searchDestination(query) {
      const resultsContainer = document.getElementById("to-results");
      
      if (!query.trim()) {
        resultsContainer.innerHTML = "";
        return;
      }

      const results = allNodes.filter((node) =>
        node.id.toLowerCase().includes(query.toLowerCase()) && 
        (!routeStartNode || node.id !== routeStartNode.id)
      );

      let resultsHTML = "";
      results.slice(0, 8).forEach((node) => {
        const label = node.label ? ` (${node.label})` : "";
        resultsHTML += `
          <div class="autocomplete-item" onclick="selectDestination('${node.id.replace(/'/g, "\\'")}')"> 
            <span>üéØ</span>
            <div>
              <div>${node.id}</div>
              <small style="color: var(--text-secondary);">${label}</small>
            </div>
          </div>`;
      });

      if (results.length === 0) {
        resultsHTML = '<div class="autocomplete-item">Aucune destination trouv√©e</div>';
      }

      resultsContainer.innerHTML = resultsHTML;
    }

    function searchOrigin(query) {
      const resultsContainer = document.getElementById("from-results");
      if (!query.trim()) {
        resultsContainer.innerHTML = "";
        return;
      }

      const results = allNodes.filter((node) =>
        node.id.toLowerCase().includes(query.toLowerCase()) &&
        (!routeEndNode || node.id !== routeEndNode.id)
      );

      let resultsHTML = "";
      results.slice(0, 8).forEach((node) => {
        const label = node.label ? ` (${node.label})` : "";
        resultsHTML += `
          <div class="autocomplete-item" onclick="selectOrigin('${node.id.replace(/'/g, "\\'")}')"> 
            <span>üìç</span>
            <div>
              <div>${node.id}</div>
              <small style="color: var(--text-secondary);">${label}</small>
            </div>
          </div>`;
      });

      if (results.length === 0) {
        resultsHTML = '<div class="autocomplete-item">Aucune origine trouv√©e</div>';
      }

      resultsContainer.innerHTML = resultsHTML;
    }

    function selectDestination(nodeId) {
      const targetNode = allNodes.find((n) => n.id === nodeId);
      if (!targetNode) return;
      
      routeEndNode = targetNode;
      document.getElementById("to-input").value = nodeId;
      document.getElementById("to-results").innerHTML = "";
      
      // Calculer automatiquement l'itin√©raire si on a les deux n≈ìuds
      if (routeStartNode) {
        calculateRoute();
      }
    }

    function selectOrigin(nodeId) {
      const targetNode = allNodes.find((n) => n.id === nodeId);
      if (!targetNode) return;
      
      routeStartNode = targetNode;
      document.getElementById("from-input").value = nodeId;
      document.getElementById("from-results").innerHTML = "";
      
      // Calculer automatiquement l'itin√©raire si on a les deux n≈ìuds
      if (routeEndNode) {
        calculateRoute();
      }
    }

    function swapRoutePoints() {
      if (!routeStartNode || !routeEndNode) return;
      
      // √âchanger les variables
      const temp = routeStartNode;
      routeStartNode = routeEndNode;
      routeEndNode = temp;
      
      // √âchanger les valeurs dans l'interface
      document.getElementById("from-input").value = routeStartNode.id;
      document.getElementById("to-input").value = routeEndNode.id;
      
      // Recalculer automatiquement l'itin√©raire
      if (routeStartNode && routeEndNode) {
        calculateRoute();
      }
    }

    function calculateRoute() {
      if (!routeStartNode || !routeEndNode) {
        console.log("Manque n≈ìud de d√©part ou destination");
        return;
      }
      
      console.log("Calcul itin√©raire de", routeStartNode.id, "vers", routeEndNode.id);
      
      // R√©initialiser le chemin pr√©c√©dent
      if (link) link.classed("path-link", false);
      if (node) node.classed("path-node", false);
      pathLinks = [];
      
      const path = findShortestPath(routeStartNode.id, routeEndNode.id);
      console.log("Chemin trouv√©:", path);
      
      const resultsContainer = document.getElementById("route-results");
      const clearButton = document.getElementById("clear-route");
      
      if (path.length === 0) {
        resultsContainer.innerHTML = `
          <div class="route-summary" style="border-left-color: #ff4444;">
            <div class="route-time" style="color: #ff4444;">‚ùå Aucun itin√©raire trouv√©</div>
            <div class="route-distance">Impossible de relier ces deux institutions</div>
          </div>`;
        clearButton.style.display = "none";
        return;
      }
      
      currentPath = path;
      
      // Mettre en surbrillance le chemin
      for (let i = 0; i < path.length - 1; i++) {
        const sourceId = path[i];
        const targetId = path[i + 1];
        
        // Trouver le lien correspondant
        const linkData = allLinks.find(l => 
          (l.source.id === sourceId && l.target.id === targetId) ||
          (l.target.id === sourceId && l.source.id === targetId)
        );
        
        if (linkData) {
          pathLinks.push(linkData);
        }
      }
      
      console.log("Liens du chemin:", pathLinks);
      
      // Appliquer les styles
      if (link) link.classed("path-link", d => pathLinks.includes(d));
      if (node) node.classed("path-node", d => path.includes(d.id));
      
      // G√©n√©rer l'affichage des r√©sultats style Google Maps
      const steps = path.length - 1;
      const estimatedTime = Math.max(1, steps * 2); // 2 min par √©tape
      
      let stepsHTML = "";
      for (let i = 0; i < path.length - 1; i++) {
        const fromNode = path[i];
        const toNode = path[i + 1];
        
        // Trouver la relation entre les n≈ìuds
        const relation = allLinks.find(l => 
          (l.source.id === fromNode && l.target.id === toNode) ||
          (l.target.id === fromNode && l.source.id === toNode)
        );
        
        const relationText = relation ? relation.type : "Connexion";
        
        stepsHTML += `
          <li class="route-step">
            <div class="step-number">${i + 1}</div>
            <div class="step-content">
              <div class="step-title">${fromNode}</div>
              <div class="step-relation">${relationText} ‚Üí ${toNode}</div>
            </div>
          </li>`;
      }
      
      resultsContainer.innerHTML = `
        <div class="route-summary">
          <div class="route-time">‚ö° ${estimatedTime} min</div>
          <div class="route-distance">${steps} √©tape${steps > 1 ? 's' : ''} ‚Ä¢ Itin√©raire institutionnel</div>
        </div>
        
        <ol class="route-steps">
          ${stepsHTML}
          <li class="route-step">
            <div class="step-number">üéØ</div>
            <div class="step-content">
              <div class="step-title">${path[path.length - 1]}</div>
              <div class="step-relation">Destination atteinte</div>
            </div>
          </li>
        </ol>
      `;
      
      clearButton.style.display = "block";
      routeMode = true;
    }

    // Close sidebar when clicking the X
    document
      .getElementById("sidebar-close")
      .addEventListener("click", closeSidebar);

    // Add search functionality
    document
      .getElementById("search-input")
      .addEventListener("input", function (e) {
        searchNodes(e.target.value);
      });

    // Add depth selector functionality
    document
      .getElementById("depth-select")
      .addEventListener("change", function (e) {
        currentDepth = parseInt(e.target.value);
        applyDepthFilter();
      });

    // Event listeners pour l'itin√©raire
    document
      .getElementById("close-route")
      .addEventListener("click", closeRoute);

    document
      .getElementById("clear-route")
      .addEventListener("click", clearRoute);

    document
      .getElementById("find-route")
      .addEventListener("click", calculateRoute);

    document
      .getElementById("to-input")
      .addEventListener("input", function (e) {
        searchDestination(e.target.value);
      });

    document
      .getElementById("from-input")
      .addEventListener("input", function (e) {
        searchOrigin(e.target.value);
      });

    document
      .getElementById("swap-route")
      .addEventListener("click", swapRoutePoints);

    // Fermer les r√©sultats d'autocompl√©tion en cliquant ailleurs
    document.addEventListener("click", function (e) {
      const toResults = document.getElementById("to-results");
      const toInput = document.getElementById("to-input");
      const fromResults = document.getElementById("from-results");
      const fromInput = document.getElementById("from-input");
      
      if (!toInput.contains(e.target) && !toResults.contains(e.target)) {
        toResults.innerHTML = "";
      }
      
      if (!fromInput.contains(e.target) && !fromResults.contains(e.target)) {
        fromResults.innerHTML = "";
      }
    });

    d3.json("graph.json", function (error, graph) {
      if (error) throw error;

      graph.links = graph.links.filter((l) => l.type != "REPRESENTE");
      graph.links = graph.links.filter((l) => l.label != "Personne");
      graph.links = graph.links.filter((l) => l.type != "EST AFFILIE AU PARTI");
      graph.links = graph.links.filter((l) => l.type != "FAIT PARTIE DES");
      graph.links = graph.links.filter((l) => l.type != "COMPOSE");
      graph.links = graph.links.filter((l) => l.type != "Repr√©sente");
      graph.links = graph.links.filter((l) => l.type != "Compose");

      // Filter out nodes that don't have any remaining links
      const linkedNodeIds = new Set();
      graph.links.forEach((link) => {
        linkedNodeIds.add(link.source);
        linkedNodeIds.add(link.target);
      });
      graph.nodes = graph.nodes.filter((node) => linkedNodeIds.has(node.id));

      // Store all links for sidebar functionality
      allLinks = graph.links;

      // Store all nodes for search functionality
      allNodes = graph.nodes;

      // graph.nodes = graph.nodes.filter(n => n.label != ("Personne"));
      update(graph.links, graph.nodes);
    });
    function update(links, nodes) {
      link = svg
        .selectAll(".link")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "link")
        .style("stroke", function (d) {
          return color(d.source);
        })
        .attr("marker-end", "url(#arrowhead)");

      link.append("title").text(function (d) {
        return d.type;
      });

      edgepaths = svg
        .selectAll(".edgepath")
        .data(links)
        .enter()
        .append("path")
        .attrs({
          class: "edgepath",
          "fill-opacity": 0,
          "stroke-opacity": 0,
          id: function (d, i) {
            return "edgepath" + i;
          },
        })
        .style("pointer-events", "none");

      edgelabels = svg
        .selectAll(".edgelabel")
        .data(links)
        .enter()
        .append("text")
        .style("pointer-events", "none")
        .attrs({
          class: "edgelabel",
          id: function (d, i) {
            return "edgelabel" + i;
          },
          "font-size": 10,
          "font-family": "Roboto",
        })
        .style("fill", function (d) {
          return color(d.source);
        });
      edgelabels
        .append("textPath")
        .attr("xlink:href", function (d, i) {
          return "#edgepath" + i;
        })
        .style("text-anchor", "middle")
        .style("pointer-events", "none")
        .attr("startOffset", "50%")
        .text(function (d) {
          return d.type;
        });

      node = svg
        .append("g")
        .attr("class", "node")
        .selectAll("circle")
        .data(nodes)
        .enter()
        .append("circle")
        .attr("r", 5)
        .attr("stroke", "var(--text-color)")
        .attr("stroke-width", 1)
        .style("fill", function (d, i) {
          return color(d.id);
        });
      // .call(d3
      // .drag()
      // .on("start", dragstarted)
      // .on("drag", dragged)
      // .on("end", dragended)
      // );

      label = svg
        .append("g")
        .attr("class", "labels")
        .selectAll("text")
        .data(nodes)
        .enter()
        .append("text")
        .attr("text-anchor", "middle")
        .style("font-family", "Roboto")
        .style("font-size", 10)
        .attr("stroke-width", "1px")
        .text(function (d) {
          return d.id;
        })
        // .call(d3
        // .drag()
        // .on("start", dragstarted)
        // .on("drag", dragged)
        // )
        .attr("stroke", function (d) {
          return labelColors(d.label);
        });

      node.on("click", function (d) {
        focusNode(d.id);
      });

      label.on("click", function (d) {
        focusNode(d.id);
      });

      node.on("mouseover", function (d) {
        node.style("opacity", function (n) {
          if (d === n) return 0.9;
          else return 0.5;
        });
        // node
        // 	.style('r', function(l) {
        // 		if (d === l )
        // 			return 30;
        // 		else
        // 			return 20;

        // });
        link.style("opacity", function (l) {
          if (d === l.source || d === l.target) return 1;
          else return 0.5;
        });
        // link
        // 	.style('stroke-width', function(l) {
        // 		if (d === l.source)
        // 			return 3;
        // 		if (d === l.target)
        // 			return 2
        // 		else
        // 			return 1;
        // });
        link.style("stroke-dasharray", function (l) {
          if (d === l.target) return "5, 5";
          else return null;
        });
      });

      simulation.nodes(nodes).on("tick", ticked);
      simulation.force("link").links(links);
    }

    simulation.alphaMin(0.2);

    function ticked() {
      // console.log(simulation.alpha());

      svg.attr("width", window.innerWidth);
      link
        .attr("x1", function (d) {
          return d.source.x;
        })
        .attr("y1", function (d) {
          return d.source.y;
        })
        .attr("x2", function (d) {
          return d.target.x;
        })
        .attr("y2", function (d) {
          return d.target.y;
        });
      node.attr("transform", function (d) {
        return "translate(" + d.x + ", " + d.y + ")";
      });
      edgepaths.attr("d", function (d) {
        return (
          "M " +
          d.source.x +
          " " +
          d.source.y +
          " L " +
          d.target.x +
          " " +
          d.target.y
        );
      });
      edgelabels.attr("transform", function (d) {
        if (d.target.x < d.source.x) {
          var bbox = this.getBBox();
          rx = bbox.x + bbox.width / 2;
          ry = bbox.y + bbox.height / 2;
          return "rotate(180 " + rx + " " + ry + ")";
        } else {
          return "rotate(0)";
        }
      });
      label
        .attr("x", function (d) {
          return d.x;
        })
        .attr("y", function (d) {
          return d.y;
        });
    }

    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = undefined;
      d.fy = undefined;
    }
  </script>
</html>
