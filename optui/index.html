<!-- 
 The goal of this experiment is to make the most accessible mobile UI for optimal reachability with one hand
 I already set constrains for a mobile viewport of 320x568px (iPhone SE 1st gen)
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>OptUI - Optimal Mobile Interface</title>
  </head>

  <style>
    /* Reset some default styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      width: 100svw;
      height: 100svh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        sans-serif;
      position: relative;
      overflow: hidden;
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* Thumb-friendly zone visualization */
    .thumb-zone {
      position: fixed;
      bottom: 0;
      right: 0;
      width: 200px;
      height: 200px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 100% 0 0 0;
      pointer-events: none;
      border: 2px dashed rgba(255, 255, 255, 0.3);
    }

    /* Header area - less accessible */
    .header {
      padding: 30px 20px 20px;
      text-align: center;
      background: rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      position: relative;
      z-index: 2;
      border-radius: 1rem;
    }

    .header h1 {
      color: white;
      font-size: 24px;
      font-weight: 300;
      margin-bottom: 8px;
    }

    .header p {
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
    }

    /* Content area */
    .content {
      padding: 20px;
      padding-bottom: 220px; /* Reserve space for thumb zone actions */
      height: calc(100% - 140px);
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      overflow-y: auto;
    }

    /* Cards in easy-reach area */
    .card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }

    .card h3 {
      color: #333;
      font-size: 18px;
      margin-bottom: 8px;
    }

    .card p {
      color: #666;
      font-size: 14px;
      line-height: 1.4;
    }

    /* Primary action buttons in thumb zone */
    .action-area {
      position: absolute;
      bottom: 110px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
    }

    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 100px;
      text-align: center;
    }

    .btn-primary {
      background: #ff6b6b;
      color: white;
      box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
    }

    .btn-primary:hover {
      background: #ff5252;
      transform: translateY(-1px);
      box-shadow: 0 6px 25px rgba(255, 107, 107, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-secondary:hover {
      background: white;
      transform: translateY(-1px);
    }

    /* Floating action button */
    .fab-container {
      z-index: 3;
      position: fixed;
      bottom: 30px;
      right: 30px;
    }

    .fab {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #4ecdc4;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(78, 205, 196, 0.3);
      transition: all 0.2s ease;
      position: relative;
      z-index: 12;
      /* Remove iOS tap highlight and focus outline */
      -webkit-tap-highlight-color: transparent;
      outline: none;
      -webkit-appearance: none;
    }

    .fab:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(78, 205, 196, 0.4);
    }

    .fab.active {
      transform: rotate(45deg);
      background: #ff6b6b;
    }

    /* FAB action menu */
    .fab-actions {
      position: absolute;
      bottom: 0;
      right: 0;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.2s ease;
      pointer-events: none;
    }

    .fab-actions.show {
      opacity: 1;
      transform: scale(1);
      pointer-events: all;
    }

    /* FAB actions positioned by JavaScript */
    .fab-action {
      position: absolute;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 3px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      /* Position will be set by JavaScript */
    }

    /* FAB action labels */
    .fab-label {
      position: absolute;
      color: white;
      font-size: 7px;
      font-weight: 600;
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px 6px;
      border-radius: 8px;
      width: 50px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0;
      transform: translateY(5px);
      transition: all 0.2s ease;
      pointer-events: none;
      /* Position will be set by JavaScript */
    }

    .fab-actions.show .fab-label {
      opacity: 1;
      transform: translateY(0);
    }

    /* Layer-specific label delays */
    .fab-label.layer-1-5 {
      transition: all 0.25s ease 0.05s;
    }

    .fab-label.layer-2 {
      transition: all 0.3s ease 0.1s;
    }

    .fab-action:hover {
      transform: translateY(-2px) scale(1.1);
    }

    .fab-action.share {
      background: #ff9500;
    }

    .fab-action.settings {
      background: #9b59b6;
    }

    .fab-action.help {
      background: #3498db;
    }

    .fab-action.close {
      background: #e74c3c;
    }

    /* Second layer button styles */
    .fab-action.search {
      background: #e74c3c;
    }

    .fab-action.bookmark {
      background: #f39c12;
    }

    .fab-action.edit {
      background: #27ae60;
    }

    .fab-action.more {
      background: #34495e;
    }

    .fab-action.notification {
      background: #e67e22;
    }

    .fab-action.profile {
      background: #2c3e50;
    }

    /* Middle layer button styles */
    .fab-action.camera {
      background: #8e44ad;
    }

    .fab-action.message {
      background: #16a085;
    }

    .fab-action.favorite {
      background: #f1c40f;
    }

    .fab-action.calendar {
      background: #e74c3c;
    }

    .fab-action.location {
      background: #34495e;
    }

    /* Middle layer buttons - between layer 1 and 2 */
    .fab-action.layer-1-5 {
      width: 46px;
      height: 46px;
      font-size: 17px;
      opacity: 0;
      transform: scale(0.7);
      transition: all 0.25s ease 0.05s;
    }

    .fab-actions.show .fab-action.layer-1-5 {
      opacity: 1;
      transform: scale(1);
    }

    /* Layer 2 buttons are slightly smaller and have delayed animation */
    .fab-action.layer-2 {
      width: 44px;
      height: 44px;
      font-size: 16px;
      opacity: 0;
      transform: scale(0.6);
      transition: all 0.3s ease 0.1s;
    }

    .fab-actions.show .fab-action.layer-2 {
      opacity: 1;
      transform: scale(1);
    }

    /* Quick access buttons in thumb zone */
    .quick-actions {
      position: absolute;
      bottom: 220px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
    }

    .quick-btn {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 15px;
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
    }

    .quick-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateX(-5px);
    }

    /* FAB menu overlay */
    .fab-overlay {
      position: fixed;
      bottom: 0;
      right: 0;
      width: 320px;
      height: 320px;
      background: radial-gradient(
        circle at bottom right,
        rgba(0, 0, 0, 0.3) 0%,
        rgba(0, 0, 0, 0.1) 60%,
        transparent 80%
      );
      backdrop-filter: blur(8px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 0;
      border-top-left-radius: 100%;
    }

    .fab-overlay.show {
      opacity: 1;
    }

    /* Demonstration overlay */
    .demo-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      cursor: pointer;
    }

    .demo-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .demo-text {
      color: white;
      text-align: center;
      font-size: 18px;
      max-width: 250px;
    }

    /* Accessibility indicators */
    .zone-indicator {
      position: absolute;
      right: 100px;
      bottom: 40px;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.6);
      font-weight: bold;
      text-align: center;
      z-index: 5;
    }

    /* Arc slider styles */
    .arc-slider-container {
      position: fixed;
      bottom: -10px;
      right: -10px;
      pointer-events: none;
      z-index: 1;
    }

    .arc-slider {
      touch-action: none;
      user-select: none;
      pointer-events: all;
    }

    #arcThumb {
      transition: all 0.1s ease;
    }

    #arcThumb:hover {
      r: 15;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.4));
    }

    #arcProgress {
      transition: stroke-dashoffset 0.1s ease;
    }

    /* Desktop styles - limit content width */
    @media (min-width: 1200px) {
      body {
        max-width: 1200px;
        margin: 0 auto;
      }
    }
  </style>

  <body>
    <!-- Thumb-friendly zone visualization -->
    <div class="thumb-zone"></div>

    <!-- Header - harder to reach -->
    <div class="header">
      <h1>OptUI Demo</h1>
      <p>One-handed mobile interface optimization</p>
      <div style="margin-top: 15px">
        <p
          style="
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin-bottom: 5px;
          "
        >
          Drag the arc to adjust button count
        </p>
      </div>
    </div>

    <!-- Main content -->
    <div class="content">
      <!-- Less important content higher up -->
      <div class="card">
        <h3>üìä Analytics</h3>
        <p>View detailed insights and performance metrics</p>
      </div>
    </div>

    <!-- Arc slider positioned around FAB buttons -->
    <div class="arc-slider-container">
      <svg class="arc-slider">
        <!-- Invisible touchable area -->
        <path
          id="arcTouchArea"
          d=""
          stroke="transparent"
          stroke-width="60"
          fill="none"
          style="cursor: pointer"
        />
        <!-- Background arc -->
        <path
          id="arcTrack"
          d=""
          stroke="rgba(255,255,255,0.2)"
          stroke-width="3"
          fill="none"
        />
        <!-- Progress arc -->
        <path
          id="arcProgress"
          d=""
          stroke="#4ecdc4"
          stroke-width="3"
          fill="none"
          stroke-dasharray="0"
          stroke-dashoffset="0"
        />
        <!-- Thumb -->
        <circle
          id="arcThumb"
          cx="130"
          cy="300"
          r="12"
          fill="#4ecdc4"
          stroke="white"
          stroke-width="3"
          style="
            cursor: pointer;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
          "
        />
        <!-- Count display -->
        <text
          id="arcCountText"
          x="210"
          y="210"
          fill="rgba(255,255,255,0.8)"
          font-size="12"
          font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif"
          text-anchor="middle"
        >
          15
        </text>
      </svg>
    </div>

    <!-- Floating action button with expandable menu -->
    <div class="fab-container">
      <!-- Overlay that appears below the buttons -->
      <div class="fab-overlay" id="fabOverlay"></div>
      <button class="fab" onclick="toggleFAB()" id="mainFAB">‚ö°</button>
      <div class="fab-actions" id="fabActions">
        <!-- First layer - closer to FAB -->
        <button class="fab-action share" onclick="shareAction()" title="Share">
          üì§
        </button>
        <div class="fab-label share-label">Share</div>
        <button
          class="fab-action settings"
          onclick="settingsAction()"
          title="Settings"
        >
          ‚öôÔ∏è
        </button>
        <div class="fab-label settings-label">Settings</div>
        <button class="fab-action help" onclick="helpAction()" title="Help">
          ‚ùì
        </button>
        <div class="fab-label help-label">Help</div>
        <button class="fab-action close" onclick="closeAction()" title="Close">
          ‚úï
        </button>
        <div class="fab-label close-label">Close</div>

        <!-- Second layer - further out -->
        <button
          class="fab-action search layer-2"
          onclick="searchAction()"
          title="Search"
        >
          üîç
        </button>
        <div class="fab-label search-label layer-2">Search</div>
        <button
          class="fab-action bookmark layer-2"
          onclick="bookmarkAction()"
          title="Bookmark"
        >
          üîñ
        </button>
        <div class="fab-label bookmark-label layer-2">Bookmark</div>
        <button
          class="fab-action edit layer-2"
          onclick="editAction()"
          title="Edit"
        >
          ‚úèÔ∏è
        </button>
        <div class="fab-label edit-label layer-2">Edit</div>
        <button
          class="fab-action more layer-2"
          onclick="moreAction()"
          title="More"
        >
          ‚ãØ
        </button>
        <div class="fab-label more-label layer-2">More</div>
        <button
          class="fab-action notification layer-2"
          onclick="notificationAction()"
          title="Notifications"
        >
          üîî
        </button>
        <div class="fab-label notification-label layer-2">Notify</div>
        <button
          class="fab-action profile layer-2"
          onclick="profileAction()"
          title="Profile"
        >
          üë§
        </button>
        <div class="fab-label profile-label layer-2">Profile</div>

        <!-- Middle layer - between layer 1 and 2 -->
        <button
          class="fab-action camera layer-1-5"
          onclick="cameraAction()"
          title="Camera"
        >
          üì∑
        </button>
        <div class="fab-label camera-label layer-1-5">Camera</div>
        <button
          class="fab-action message layer-1-5"
          onclick="messageAction()"
          title="Messages"
        >
          üí¨
        </button>
        <div class="fab-label message-label layer-1-5">Messages</div>
        <button
          class="fab-action favorite layer-1-5"
          onclick="favoriteAction()"
          title="Favorites"
        >
          ‚≠ê
        </button>
        <div class="fab-label favorite-label layer-1-5">Favorites</div>
        <button
          class="fab-action calendar layer-1-5"
          onclick="calendarAction()"
          title="Calendar"
        >
          üìÖ
        </button>
        <div class="fab-label calendar-label layer-1-5">Calendar</div>
        <button
          class="fab-action location layer-1-5"
          onclick="locationAction()"
          title="Location"
        >
          üìç
        </button>
        <div class="fab-label location-label layer-1-5">Location</div>
      </div>
    </div>

    <!-- Demo overlay -->
    <div class="demo-overlay" id="demoOverlay" onclick="hideOverlay()">
      <div class="demo-text" id="demoText">
        Thumb-friendly zone optimizes for natural hand position
      </div>
    </div>

    <script>
      let demoActive = false;
      let zoneVisible = true;
      let fabOpen = false;
      let currentButtonCount = 15;
      let isDragging = false;

      // Position FAB actions using dynamic arc calculations
      function positionFABActions() {
        const actions = document.querySelectorAll(".fab-action");
        const labels = document.querySelectorAll(".fab-label");
        const fabButton = document.querySelector(".fab");

        // Configuration based on human thumb reach ergonomics
        const config = {
          baseRadius: 110, // ~110px from corner = comfortable thumb reach with clearance
          radiusMultiplier: 1.9, // Second layer at ~209px = maximum separation
          maxArcAngle: 85, // 85¬∞ arc = wider spread for layer 1 buttons
          buttonSizeRatio: 0.9, // Layer 2 slightly smaller for easier targeting
          minButtonGap: 24, // 24px minimum gap for better touch accuracy
          labelOffset: 28, // Distance below button for label
        };

        setTimeout(() => {
          // Filter visible actions based on current button count
          const visibleActions = Array.from(actions).filter(
            (action, index) =>
              index < currentButtonCount && action.style.display !== "none"
          );
          const visibleLabels = Array.from(labels).filter(
            (label, index) =>
              index < currentButtonCount && label.style.display !== "none"
          );

          // Separate visible actions and labels by layer
          const layer1Actions = visibleActions.filter((_, i) => i < 4);
          const layer15Actions = visibleActions.filter((action) =>
            action.classList.contains("layer-1-5")
          );
          const layer2Actions = visibleActions.filter((action) =>
            action.classList.contains("layer-2")
          );

          const layer1Labels = visibleLabels.filter((_, i) => i < 4);
          const layer15Labels = visibleLabels.filter((label) =>
            label.classList.contains("layer-1-5")
          );
          const layer2Labels = visibleLabels.filter((label) =>
            label.classList.contains("layer-2")
          );

          // Calculate optimal spacing for each layer
          function positionLayer(layerActions, layerLabels, layerIndex) {
            const radiusMultipliers = [1.2, 1.7, 2.2]; // Layer 1, 1.5, 2 spacing - increased separation
            const radius = config.baseRadius * radiusMultipliers[layerIndex];
            const buttonCount = layerActions.length;

            // Button sizes for each layer
            const buttonSizes = [48, 46, 44]; // Layer 1, 1.5, 2 sizes
            const buttonSize = buttonSizes[layerIndex];

            // Ensure minimum gap between buttons
            const minAngleForGap =
              Math.asin(config.minButtonGap / radius) * (180 / Math.PI) * 2;

            let angleStep, startAngle;

            if (buttonCount === 1) {
              // Single button goes to center (45 degrees)
              angleStep = 0;
              startAngle = 45;
            } else {
              // For multiple buttons, distribute evenly within the arc
              // Use a portion of the full arc based on button count
              const arcUtilization = Math.min(1, buttonCount / 4); // Use more arc as button count increases
              const usedArc = config.maxArcAngle * arcUtilization;

              // Calculate step ensuring minimum gap
              const maxAngleStep = usedArc / Math.max(1, buttonCount - 1);
              angleStep = Math.max(maxAngleStep, minAngleForGap);

              // Center the arc around 45 degrees (optimal thumb reach)
              const totalArc = angleStep * Math.max(0, buttonCount - 1);
              startAngle = 45 - totalArc / 2;
            }

            layerActions.forEach((action, buttonIndex) => {
              const angle = startAngle + buttonIndex * angleStep;
              const radians = (angle * Math.PI) / 180;

              // Calculate position
              const x = radius * Math.cos(radians);
              const y = radius * Math.sin(radians);

              // Center button on calculated point
              const centerOffset = buttonSize / 2;
              action.style.right = x - centerOffset + "px";
              action.style.bottom = y - centerOffset + "px";

              // Position corresponding label below button
              if (layerLabels[buttonIndex]) {
                const label = layerLabels[buttonIndex];
                const labelY = y - config.labelOffset;
                const labelWidth = 50; // Fixed width from CSS
                label.style.right = x - labelWidth / 2 + "px"; // Center label precisely
                label.style.bottom = labelY + "px";
              }
            });
          }

          // Position all three layers
          positionLayer(layer1Actions, layer1Labels, 0);
          positionLayer(layer15Actions, layer15Labels, 1);
          positionLayer(layer2Actions, layer2Labels, 2);
        }, 50);
      }

      function toggleFAB() {
        const fab = document.getElementById("mainFAB");
        const actions = document.getElementById("fabActions");
        const overlay = document.getElementById("fabOverlay");

        if (!fabOpen) {
          fab.classList.add("active");
          actions.classList.add("show");
          overlay.classList.add("show");
          fabOpen = true;
        } else {
          fab.classList.remove("active");
          actions.classList.remove("show");
          overlay.classList.remove("show");
          fabOpen = false;
        }
      }

      function shareAction() {
        showDemoMessage(
          "üì§ Share functionality - Export your optimal UI design"
        );
        toggleFAB(); // Close FAB menu
      }

      function settingsAction() {
        showDemoMessage("‚öôÔ∏è Settings - Customize thumb reach preferences");
        toggleFAB(); // Close FAB menu
      }

      function helpAction() {
        showDemoMessage("‚ùì Help - Learn about one-handed UI optimization");
        toggleFAB(); // Close FAB menu
      }

      function closeAction() {
        showDemoMessage("‚úï Close - Exit or dismiss current view");
        toggleFAB(); // Close FAB menu
      }

      function searchAction() {
        showDemoMessage(
          "üîç Search - Find content optimized for thumb navigation"
        );
        toggleFAB(); // Close FAB menu
      }

      function bookmarkAction() {
        showDemoMessage("üîñ Bookmark - Save this optimal UI pattern");
        toggleFAB(); // Close FAB menu
      }

      function editAction() {
        showDemoMessage("‚úèÔ∏è Edit - Modify thumb zone preferences");
        toggleFAB(); // Close FAB menu
      }

      function moreAction() {
        showDemoMessage("‚ãØ More - Additional thumb-friendly options");
        toggleFAB(); // Close FAB menu
      }

      function notificationAction() {
        showDemoMessage("üîî Notifications - Check your alerts and updates");
        toggleFAB(); // Close FAB menu
      }

      function profileAction() {
        showDemoMessage("üë§ Profile - Manage your account and preferences");
        toggleFAB(); // Close FAB menu
      }

      function cameraAction() {
        showDemoMessage("üì∑ Camera - Capture moments with optimal reach");
        toggleFAB(); // Close FAB menu
      }

      function messageAction() {
        showDemoMessage("üí¨ Messages - Quick access to conversations");
        toggleFAB(); // Close FAB menu
      }

      function favoriteAction() {
        showDemoMessage("‚≠ê Favorites - Access your starred content");
        toggleFAB(); // Close FAB menu
      }

      function calendarAction() {
        showDemoMessage("üìÖ Calendar - View your schedule and events");
        toggleFAB(); // Close FAB menu
      }

      function locationAction() {
        showDemoMessage("üìç Location - Find places and get directions");
        toggleFAB(); // Close FAB menu
      }

      function showDemoMessage(message) {
        const overlay = document.getElementById("demoOverlay");
        const text = document.getElementById("demoText");

        overlay.classList.add("active");
        text.innerHTML = message;

        // Auto-hide after 3 seconds if not clicked
        setTimeout(() => {
          overlay.classList.remove("active");
        }, 3000);
      }

      function hideOverlay() {
        const overlay = document.getElementById("demoOverlay");
        overlay.classList.remove("active");
      }

      function toggleDemo() {
        showDemoMessage(
          "‚úã Primary actions are positioned in the natural thumb reach area"
        );
      }

      function showZone() {
        const thumbZone = document.querySelector(".thumb-zone");
        const indicator = document.querySelector(".zone-indicator");

        if (zoneVisible) {
          thumbZone.style.opacity = "0";
          indicator.style.opacity = "0";
          zoneVisible = false;
        } else {
          thumbZone.style.opacity = "1";
          indicator.style.opacity = "1";
          zoneVisible = true;
        }
      }

      function simulate() {
        showDemoMessage(
          "üöÄ Interface optimized for 85% of users' natural thumb reach"
        );
      }

      // Close FAB menu when clicking outside
      function closeFABOnOutsideClick(event) {
        if (!fabOpen) return;

        const fabContainer = document.querySelector(".fab-container");
        const arcSliderContainer = document.querySelector(
          ".arc-slider-container"
        );
        const clickedElement = event.target;

        // Check if click was outside the FAB container and arc slider
        if (
          !fabContainer.contains(clickedElement) &&
          !arcSliderContainer.contains(clickedElement)
        ) {
          toggleFAB();
        }
      }

      // Add event listener for outside clicks
      document.addEventListener("click", closeFABOnOutsideClick);
      document.addEventListener("touchstart", closeFABOnOutsideClick);

      // Arc slider functionality
      function initArcSlider() {
        const thumb = document.getElementById("arcThumb");
        const progress = document.getElementById("arcProgress");
        const countText = document.getElementById("arcCountText");
        const svg = document.querySelector(".arc-slider");

        // Arc slider configuration for optimal thumb reach
        const sliderConfig = {
          radius: 340, // Large radius to encompass FAB button layers
          startAngle: -100, // Top of arc with padding (15 buttons)
          endAngle: -170, // Left of arc with padding (0 buttons)
        };

        // Calculate canvas size to contain the full arc with padding
        const canvasSize = Math.ceil(sliderConfig.radius * 2.2); // 2.2x radius for adequate padding
        const centerOffset = canvasSize / 2;
        sliderConfig.centerX = centerOffset;
        sliderConfig.centerY = centerOffset;
        sliderConfig.canvasSize = canvasSize;

        // Update SVG and container size dynamically
        svg.setAttribute("width", canvasSize);
        svg.setAttribute("height", canvasSize);
        svg.setAttribute("viewBox", `0 0 ${canvasSize} ${canvasSize}`);

        const container = document.querySelector(".arc-slider-container");
        container.style.width = `${canvasSize}px`;
        container.style.height = `${canvasSize}px`;

        // Position container so the arc center aligns with bottom-right corner of viewport
        const offset = centerOffset; // Center the arc at the corner
        container.style.bottom = `-${offset}px`;
        container.style.right = `-${offset}px`;

        // Generate SVG arc path dynamically
        function generateArcPath(config) {
          const startX =
            config.centerX +
            config.radius * Math.cos((config.startAngle * Math.PI) / 180);
          const startY =
            config.centerY +
            config.radius * Math.sin((config.startAngle * Math.PI) / 180);
          const endX =
            config.centerX +
            config.radius * Math.cos((config.endAngle * Math.PI) / 180);
          const endY =
            config.centerY +
            config.radius * Math.sin((config.endAngle * Math.PI) / 180);

          return `M ${startX} ${startY} A ${config.radius} ${config.radius} 0 0 0 ${endX} ${endY}`;
        }

        // Update SVG paths with generated ones
        const arcPath = generateArcPath(sliderConfig);
        document.getElementById("arcTouchArea").setAttribute("d", arcPath);
        document.getElementById("arcTrack").setAttribute("d", arcPath);
        document.getElementById("arcProgress").setAttribute("d", arcPath);

        // Calculate arc length for progress visualization
        const angleRange = Math.abs(
          sliderConfig.endAngle - sliderConfig.startAngle
        ); // Total angle span of the arc (70 degrees)
        const arcLength =
          (2 * Math.PI * sliderConfig.radius * angleRange) / 360;
        // Set dasharray to the full arc length so we can control visibility with dashoffset
        document
          .getElementById("arcProgress")
          .setAttribute(
            "stroke-dasharray",
            `${arcLength.toFixed(1)} ${arcLength.toFixed(1)}`
          );

        // Position counter text outside the arc
        const counterDistance = sliderConfig.radius + 60; // 60px outside the arc
        const counterAngle = -135; // Middle of the arc range (-100 to -170)
        const counterX =
          sliderConfig.centerX +
          counterDistance * Math.cos((counterAngle * Math.PI) / 180);
        const counterY =
          sliderConfig.centerY +
          counterDistance * Math.sin((counterAngle * Math.PI) / 180);

        countText.setAttribute("x", counterX);
        countText.setAttribute("y", counterY);

        function updateSliderFromValue(value) {
          const percentage = value / 15; // Convert count (0-15) to percentage (0-1)
          // Map percentage to angle within our arc range
          const angle =
            sliderConfig.startAngle +
            (1 - percentage) *
              (sliderConfig.endAngle - sliderConfig.startAngle);
          const radians = (angle * Math.PI) / 180;

          // Calculate thumb position using computed values
          const x =
            sliderConfig.centerX + sliderConfig.radius * Math.cos(radians);
          const y =
            sliderConfig.centerY + sliderConfig.radius * Math.sin(radians);

          thumb.setAttribute("cx", x);
          thumb.setAttribute("cy", y);

          // Update progress arc to fill from handle position as count increases
          // Arc path goes from startAngle (-100¬∞, 15 buttons) to endAngle (-170¬∞, 0 buttons)
          // Progress should fill from handle's current position toward the startAngle (higher counts)
          const progressPercentage = percentage; // value/15: 0 at min count, 1 at max count
          const progressLength = arcLength * progressPercentage; // Length of arc to fill
          const dashOffset = -arcLength + progressLength; // Offset pattern to show progress from handle position
          progress.style.strokeDashoffset = dashOffset;

          // Update count text
          countText.textContent = value;
        }

        function getValueFromPosition(clientX, clientY) {
          const rect = svg.getBoundingClientRect();

          // Account for potential viewport scaling on mobile devices
          const scale = window.devicePixelRatio || 1;
          const svgX =
            (clientX - rect.left) * (sliderConfig.canvasSize / rect.width);
          const svgY =
            (clientY - rect.top) * (sliderConfig.canvasSize / rect.height);

          // Use computed configuration for consistent positioning
          const dx = svgX - sliderConfig.centerX;
          const dy = svgY - sliderConfig.centerY;

          let angle = Math.atan2(dy, dx) * (180 / Math.PI);

          // Keep angle in -180 to +180 range consistently
          while (angle > 180) angle -= 360;
          while (angle < -180) angle += 360;

          // Clamp to the configured arc range (-170¬∞ to -100¬∞)
          angle = Math.max(
            sliderConfig.endAngle,
            Math.min(sliderConfig.startAngle, angle)
          );

          // Convert clamped angle back to 0-1 percentage
          // startAngle (-100¬∞) = max buttons (15), endAngle (-170¬∞) = min buttons (0)
          const percentage =
            (sliderConfig.endAngle - angle) /
            (sliderConfig.endAngle - sliderConfig.startAngle);
          const value = Math.round(percentage * 15);

          return value;
        }

        // Get touch area element
        const touchArea = document.getElementById("arcTouchArea");
        // Drag and click functionality
        function updateFromEvent(e) {
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          const value = getValueFromPosition(clientX, clientY);
          updateButtonCount(value);
        }

        function handleStart(e) {
          isDragging = true;
          updateFromEvent(e);
        }

        function handleMove(e) {
          if (!isDragging) return;
          e.preventDefault();
          updateFromEvent(e);
        }

        function handleEnd() {
          isDragging = false;
        }

        // Mouse events
        svg.addEventListener("mousedown", handleStart);
        document.addEventListener("mousemove", handleMove);
        document.addEventListener("mouseup", handleEnd);

        // Touch events (without preventDefault on touchstart to avoid browser warning)
        svg.addEventListener("touchstart", handleStart);
        document.addEventListener("touchmove", handleMove, { passive: false });
        document.addEventListener("touchend", handleEnd);

        // Initialize position to match the actual arc endpoints
        updateSliderFromValue(15);

        // Update slider when button count changes
        window.updateSliderFromValue = updateSliderFromValue;
      }

      // Override the existing updateButtonCount function to work with arc slider
      function updateButtonCount(count) {
        currentButtonCount = parseInt(count);

        // Update slider visual
        if (window.updateSliderFromValue) {
          window.updateSliderFromValue(count);
        }

        // Hide/show buttons based on count
        const allActions = document.querySelectorAll(".fab-action");
        const allLabels = document.querySelectorAll(".fab-label");

        allActions.forEach((action, index) => {
          if (index < currentButtonCount) {
            action.style.display = "flex";
          } else {
            action.style.display = "none";
          }
        });

        allLabels.forEach((label, index) => {
          if (index < currentButtonCount) {
            label.style.display = "block";
          } else {
            label.style.display = "none";
          }
        });

        // Reposition remaining buttons
        setTimeout(() => {
          positionFABActions();
        }, 10);
      }

      // Initialize positioning on load
      setTimeout(() => {
        initArcSlider();
        positionFABActions();
        // Open FAB menu on page load
        toggleFAB();
      }, 100);
    </script>
  </body>
</html>
